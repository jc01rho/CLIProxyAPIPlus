# Kilocode Model Fetching - 기술적 결정사항

## 아키텍처 결정

### 1. 무료 모델 필터링 전략
**결정**: API 응답에서 클라이언트 측 필터링
**근거**: 
- Kilocode API는 모든 모델을 반환하므로 클라이언트에서 필터링 필요
- `pricing.prompt == "0" && pricing.completion == "0"` 조건으로 무료 모델 식별
- 서버 측 필터링보다 유연하고 API 변경에 덜 민감

### 2. Static Fallback 없음
**결정**: Kilocode는 API 실패 시 빈 배열 반환
**근거**:
- Kiro와 달리 Kilocode는 정적 모델 정의가 없음
- 무료 모델 목록이 동적으로 변경될 수 있음
- API 실패 시 오래된 정보보다 빈 목록이 더 안전

### 3. 토큰 추출 우선순위
**결정**: Attributes (config.yaml) > Metadata (JSON 파일)
**근거**:
- config.yaml의 설정이 더 명시적이고 관리하기 쉬움
- JSON 파일은 런타임 생성되므로 보조적 역할
- 기존 Kiro 패턴과 일관성 유지

### 4. 모델 ID 정규화
**결정**: "kilocode-" 접두사 자동 추가
**근거**:
- 다른 프로바이더와 모델 ID 충돌 방지
- 일관된 명명 규칙으로 관리 용이성 향상
- 기존 "kiro-" 패턴과 동일한 접근법

## API 설계 결정

### 1. OpenRouter 호환성
**결정**: Kilocode API가 OpenRouter 형식 사용
**근거**:
- 기존 OpenRouter 클라이언트와 호환성
- 표준화된 API 스펙 활용
- 구현 복잡도 감소

### 2. 타임아웃 설정
**결정**: 15초 타임아웃 (Kiro와 동일)
**근거**:
- 네트워크 지연 고려한 충분한 시간
- 너무 길면 사용자 경험 저하
- 기존 패턴과 일관성

### 3. 에러 처리 전략
**결정**: 로그 기반 에러 처리, 빈 배열 반환
**근거**:
- 서비스 전체 중단보다 부분 실패 허용
- 디버깅을 위한 상세 로그 제공
- 다른 프로바이더 영향 최소화

## 보안 결정

### 1. 토큰 마스킹
**결정**: 로그에서 토큰 앞뒤 4자리만 표시
**근거**:
- 디버깅 시 토큰 식별 가능
- 전체 토큰 노출 방지
- 기존 보안 패턴 준수

### 2. 인증 헤더 형식
**결정**: `Authorization: Bearer {token}` 표준 사용
**근거**:
- OAuth 2.0 표준 준수
- 대부분의 HTTP 클라이언트에서 지원
- 보안 모범 사례

## 성능 결정

### 1. 메모리 효율성
**결정**: 필요한 필드만 포함한 구조체 설계
**근거**:
- 불필요한 메모리 사용 방지
- JSON 파싱 성능 향상
- 타입 안전성 유지

### 2. 동시성 고려
**결정**: Context 기반 타임아웃 및 취소
**근거**:
- 고루틴 리소스 누수 방지
- 사용자 요청 취소 시 즉시 중단
- Go 표준 패턴 활용

## 확장성 결정

### 1. 인터페이스 분리
**결정**: Auth와 Model Converter 분리
**근거**:
- 단일 책임 원칙 준수
- 테스트 용이성 향상
- 향후 확장 시 유연성

### 2. 설정 기반 확장
**결정**: 하드코딩 최소화, 설정 파일 활용
**근거**:
- 런타임 설정 변경 가능
- 다양한 환경 지원
- 유지보수성 향상